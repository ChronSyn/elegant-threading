(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
  else if (typeof exports === 'object') exports.elegantThreading = factory();
  else root.elegantThreading = factory();
}(window, () =>
/** *** */ (function (modules) { // webpackBootstrap
    /** *** */ 	// The module cache
    /** *** */ 	const installedModules = {};
    /** *** */
    /** *** */ 	// The require function
    /** *** */ 	function __webpack_require__(moduleId) {
      /** *** */
      /** *** */ 		// Check if module is in cache
      /** *** */ 		if (installedModules[moduleId]) {
        /** *** */ 			return installedModules[moduleId].exports;
        /** *** */ 		}
      /** *** */ 		// Create a new module (and put it into the cache)
      /** *** */ 		const module = installedModules[moduleId] = {
        /** *** */ 			i: moduleId,
        /** *** */ 			l: false,
        /** *** */ 			exports: {},
        /** *** */ 		};
      /** *** */
      /** *** */ 		// Execute the module function
      /** *** */ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
      /** *** */
      /** *** */ 		// Flag the module as loaded
      /** *** */ 		module.l = true;
      /** *** */
      /** *** */ 		// Return the exports of the module
      /** *** */ 		return module.exports;
      /** *** */ 	}
    /** *** */
    /** *** */
    /** *** */ 	// expose the modules object (__webpack_modules__)
    /** *** */ 	__webpack_require__.m = modules;
    /** *** */
    /** *** */ 	// expose the module cache
    /** *** */ 	__webpack_require__.c = installedModules;
    /** *** */
    /** *** */ 	// define getter function for harmony exports
    /** *** */ 	__webpack_require__.d = function (exports, name, getter) {
      /** *** */ 		if (!__webpack_require__.o(exports, name)) {
        /** *** */ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
        /** *** */ 		}
      /** *** */ 	};
    /** *** */
    /** *** */ 	// define __esModule on exports
    /** *** */ 	__webpack_require__.r = function (exports) {
      /** *** */ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        /** *** */ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
        /** *** */ 		}
      /** *** */ 		Object.defineProperty(exports, '__esModule', { value: true });
      /** *** */ 	};
    /** *** */
    /** *** */ 	// create a fake namespace object
    /** *** */ 	// mode & 1: value is a module id, require it
    /** *** */ 	// mode & 2: merge all properties of value into the ns
    /** *** */ 	// mode & 4: return value when already ns object
    /** *** */ 	// mode & 8|1: behave like require
    /** *** */ 	__webpack_require__.t = function (value, mode) {
      /** *** */ 		if (mode & 1) value = __webpack_require__(value);
      /** *** */ 		if (mode & 8) return value;
      /** *** */ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
      /** *** */ 		const ns = Object.create(null);
      /** *** */ 		__webpack_require__.r(ns);
      /** *** */ 		Object.defineProperty(ns, 'default', { enumerable: true, value });
      /** *** */ 		if (mode & 2 && typeof value !== 'string') for (const key in value) __webpack_require__.d(ns, key, ((key) => value[key]).bind(null, key));
      /** *** */ 		return ns;
      /** *** */ 	};
    /** *** */
    /** *** */ 	// getDefaultExport function for compatibility with non-harmony modules
    /** *** */ 	__webpack_require__.n = function (module) {
      /** *** */ 		const getter = module && module.__esModule
      /** *** */ 			? function getDefault() { return module.default; }
      /** *** */ 			: function getModuleExports() { return module; };
      /** *** */ 		__webpack_require__.d(getter, 'a', getter);
      /** *** */ 		return getter;
      /** *** */ 	};
    /** *** */
    /** *** */ 	// Object.prototype.hasOwnProperty.call
    /** *** */ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
    /** *** */
    /** *** */ 	// __webpack_public_path__
    /** *** */ 	__webpack_require__.p = '';
    /** *** */
    /** *** */
    /** *** */ 	// Load entry module and return exports
    /** *** */ 	return __webpack_require__(__webpack_require__.s = './src/index.js');
    /** *** */ }({

    /***/ './node_modules/@babel/runtime/helpers/arrayWithHoles.js':
    /*! ***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \************************************************************** */
    /*! no static exports found */
    /***/ (function (module, exports) {
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
      }

      module.exports = _arrayWithHoles;
      /***/ }),

    /***/ './node_modules/@babel/runtime/helpers/iterableToArrayLimit.js':
    /*! *********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \******************************************************************** */
    /*! no static exports found */
    /***/ (function (module, exports) {
      function _iterableToArrayLimit(arr, i) {
        if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === '[object Arguments]')) {
          return;
        }

        const _arr = [];
        let _n = true;
        let _d = false;
        let _e;

        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);

            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i.return != null) _i.return();
          } finally {
            if (_d) throw _e;
          }
        }

        return _arr;
      }

      module.exports = _iterableToArrayLimit;
      /***/ }),

    /***/ './node_modules/@babel/runtime/helpers/nonIterableRest.js':
    /*! ****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \*************************************************************** */
    /*! no static exports found */
    /***/ (function (module, exports) {
      function _nonIterableRest() {
        throw new TypeError('Invalid attempt to destructure non-iterable instance');
      }

      module.exports = _nonIterableRest;
      /***/ }),

    /***/ './node_modules/@babel/runtime/helpers/slicedToArray.js':
    /*! **************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \************************************************************* */
    /*! no static exports found */
    /***/ (function (module, exports, __webpack_require__) {
      const arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ './node_modules/@babel/runtime/helpers/arrayWithHoles.js');

      const iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ './node_modules/@babel/runtime/helpers/iterableToArrayLimit.js');

      const nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ './node_modules/@babel/runtime/helpers/nonIterableRest.js');

      function _slicedToArray(arr, i) {
        return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
      }

      module.exports = _slicedToArray;
      /***/ }),

    /***/ './src/browserThreading.js':
    /*! *********************************!*\
  !*** ./src/browserThreading.js ***!
  \******************************** */
    /*! no static exports found */
    /***/ (function (module, exports, __webpack_require__) {
      const stringifyExpored = __webpack_require__(/*! ./stringifyExpored */ './src/stringifyExpored.js');

      let id = 0;

      function browserThreading(source, exported) {
        const _window = window;
        const { Blob } = _window;
        const { URL } = _window;
        const { Worker } = _window;
        const worker = new Worker(URL.createObjectURL(new Blob(['\n      '.concat(stringifyExpored(exported), '\n      var f000 = ').concat(source.toString(), ';\n      onmessage = function(e) {\n        postMessage({ result: f000.apply(this, e.data.message), id: e.data.id });\n      }\n    ')], {
          type: 'text/javascript',
        })));

        const threadedFunction = function threadedFunction() {
          for (var _len = arguments.length, message = new Array(_len), _key = 0; _key < _len; _key++) {
            message[_key] = arguments[_key];
          }

          return new Promise(((resolve, reject) => {
            const currentId = id++;

            const onMessage = function onMessage(_ref) {
              const { data } = _ref;

              if (data.id === currentId) {
                resolve(data.result);
                worker.removeEventListener('message', onMessage);
                worker.removeEventListener('message', onError); // eslint-disable-line no-use-before-define
              }
            };

            var onError = function onError(e) {
              reject(e);
              worker.removeEventListener('message', onMessage);
              worker.removeEventListener('message', onError);
            };

            worker.postMessage({
              message,
              id: currentId,
            });
            worker.addEventListener('message', onMessage);
            worker.addEventListener('error', onError);
          }));
        };

        threadedFunction.terminate = function () {
          return worker.terminate();
        };

        return threadedFunction;
      }

      module.exports = browserThreading;
      /***/ }),

    /***/ './src/index.js':
    /*! **********************!*\
  !*** ./src/index.js ***!
  \********************* */
    /*! no static exports found */
    /***/ (function (module, exports, __webpack_require__) {
      const browserThreading = __webpack_require__(/*! ./browserThreading */ './src/browserThreading.js');

      const nodeThreading = __webpack_require__(/*! ./nodeThreading */ './src/nodeThreading.js');

      function elegantThreading(source, imports) {
        let threadedFunction;

        if (typeof window !== 'undefined' && typeof window.Worker === 'function') {
          threadedFunction = browserThreading(source, imports);
        } else {
          threadedFunction = nodeThreading(source, imports);
        } // calculateHeavyThing.fork()(...args)


        threadedFunction.fork = function () {
          return elegantThreading(source, imports);
        };

        return threadedFunction;
      }

      module.exports = elegantThreading;
      /***/ }),

    /***/ './src/nodeThreading.js':
    /*! ******************************!*\
  !*** ./src/nodeThreading.js ***!
  \***************************** */
    /*! no static exports found */
    /***/ (function (module, exports, __webpack_require__) {
      const stringifyExpored = __webpack_require__(/*! ./stringifyExpored */ './src/stringifyExpored.js');

      let id = 0;

      function nodeThreading(source, exported) {
        // eval is used to get "require" function but it should be invisible for bundlers like Webpack
        const _eval = eval('require')('worker_threads');
        const { Worker } = _eval; // eslint-disable-line no-eval


        const worker = new Worker("\n      const { parentPort, MessageChannel } = require('worker_threads');\n      ".concat(stringifyExpored(exported), '\n      const f000 = ').concat(source.toString(), ";\n      parentPort.on('message', function(data) {\n        parentPort.postMessage({ result: f000.apply(this, data.message), id: data.id });\n      });\n\n    "), {
          eval: true,
        });
        const symbols = Object.getOwnPropertySymbols(worker);
        const kHandleSymbol = symbols.find((_ref) => {
          const { description } = _ref;
          return description === 'kHandle';
        });
        const kHandle = worker[kHandleSymbol];

        const threadedFunction = function threadedFunction() {
          for (var _len = arguments.length, message = new Array(_len), _key = 0; _key < _len; _key++) {
            message[_key] = arguments[_key];
          }

          return new Promise(((resolve, reject) => {
            const currentId = id++;

            const onMessage = function onMessage(data) {
              if (data.id === currentId) {
                kHandle.unref();
                resolve(data.result);
                worker.off('message', onMessage);
                worker.off('message', onError); // eslint-disable-line no-use-before-define
              }
            };

            var onError = function onError(e) {
              kHandle.unref();
              reject(e);
              worker.off('message', onMessage);
              worker.off('message', onError);
            };

            kHandle.ref();
            worker.postMessage({
              message,
              id: currentId,
            });
            worker.on('message', onMessage);
            worker.on('error', onError);
          }));
        };

        threadedFunction.terminate = function () {
          return worker.terminate();
        };

        return threadedFunction;
      }

      module.exports = nodeThreading;
      /***/ }),

    /***/ './src/stringifyExpored.js':
    /*! *********************************!*\
  !*** ./src/stringifyExpored.js ***!
  \******************************** */
    /*! no static exports found */
    /***/ (function (module, exports, __webpack_require__) {
      const _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ './node_modules/@babel/runtime/helpers/slicedToArray.js');

      function stringifyExpored() {
        const exported = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return Object.entries(exported).map((_ref) => {
          const _ref2 = _slicedToArray(_ref, 2);
          const name = _ref2[0];
          const func = _ref2[1];

          return 'const '.concat(name, ' = ').concat(func.toString(), ';\n');
        });
      }

      module.exports = stringifyExpored;
      /***/ }),

    /** *** */ }))));
// # sourceMappingURL=elegant-threading.min.js.map
